generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  full_name String
  email     String   @unique
  role      Role
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation to invitations
  sentInvites Invitation[] @relation("UserInvitations")

  // Relation to assets
  assets Asset[] @relation("UserAssets")
  // Relation to shared assets
  sharedAssets AssetShare[]
  // Relation to restricted shares
  restrictedShares AssetShare[] @relation("RestrictedShares")
}

model Invitation {
  id         String           @id @default(uuid())
  email      String
  role       InvitationRole // only USER or MANAGER
  status     InvitationStatus @default(PENDING)
  inviteBy   String
  invitedBy  User             @relation("UserInvitations", fields: [inviteBy], references: [id])
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @default(now()) @updatedAt
  acceptedAt DateTime?
}

model Asset {
  asset_id     String          @id @default(uuid())
  filename     String          @db.VarChar(255)
  mime_type    String          @db.VarChar(50)
  storage_path String          @db.VarChar(255)
  uploader_id  String
  uploader     User            @relation("UserAssets", fields: [uploader_id], references: [id])
  group_id     String? // nullable
  size_bytes   Int
  status       AssetStatus     @default(START)
  created_at   DateTime        @default(now())
  updated_at   DateTime        @updatedAt
  // Relation to metadata
  metadata     AssetMetadata[]
  // Relation to transcoding jobs
  transcodingJobs TranscodingJob[]
  // Relation to sharing
  shares       AssetShare[]
}

model AssetMetadata {
  metadata_id String   @id @default(uuid())
  asset_id    String
  asset       Asset    @relation(fields: [asset_id], references: [asset_id])
  key         String
  value       Json
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@unique([asset_id, key])
}

enum AssetStatus {
  START
  COMPLETED
}

enum Role {
  ADMIN
  USER
  MANAGER
}

enum InvitationStatus {
  PENDING
  JOINED
}

enum InvitationRole {
  USER
  MANAGER
}

model TranscodingJob {
  id         String    @id @default(uuid())
  asset_id   String
  job_id     String    @unique
  worker_name String   @default("unknown")
  event_name  String   @default("enqueued")
  status     JobStatus @default(PENDING)
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt

  asset Asset @relation(fields: [asset_id], references: [asset_id])

  @@index([asset_id])
}

enum JobStatus {
  PENDING
  ACTIVE
  COMPLETED
  FAILED
}

model AssetShare {
  id          String   @id @default(uuid())
  asset_id    String
  asset       Asset    @relation(fields: [asset_id], references: [asset_id])
  shared_by   String
  sharedBy    User     @relation(fields: [shared_by], references: [id])
  share_type  String   // 'PUBLIC' or 'RESTRICTED'
  share_token String   @unique
  user_id     String?  // For RESTRICTED shares - which user can access
  user        User?    @relation("RestrictedShares", fields: [user_id], references: [id])
  is_active   Boolean  @default(true)
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
  
  @@index([asset_id])
  @@index([shared_by])
  @@index([share_token])
  @@index([user_id])
}
